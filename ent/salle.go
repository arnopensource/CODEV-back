// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/abc3354/CODEV-back/ent/salle"
)

// Salle is the model entity for the Salle schema.
type Salle struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Nom holds the value of the "nom" field.
	Nom string `json:"nom,omitempty"`
	// Batiment holds the value of the "batiment" field.
	Batiment string `json:"batiment,omitempty"`
	// Etage holds the value of the "etage" field.
	Etage string `json:"etage,omitempty"`
	// NumSalle holds the value of the "num_salle" field.
	NumSalle string `json:"num_salle,omitempty"`
	// CapMax holds the value of the "cap_max" field.
	CapMax int `json:"cap_max,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SalleQuery when eager-loading is set.
	Edges SalleEdges `json:"edges"`
}

// SalleEdges holds the relations/edges for other nodes in the graph.
type SalleEdges struct {
	// ProfilReservation holds the value of the profil_reservation edge.
	ProfilReservation []*Profile `json:"profil_reservation,omitempty"`
	// Disponibilite holds the value of the disponibilite edge.
	Disponibilite []*SalleDisponible `json:"disponibilite,omitempty"`
	// Reservations holds the value of the reservations edge.
	Reservations []*Reservation `json:"reservations,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// ProfilReservationOrErr returns the ProfilReservation value or an error if the edge
// was not loaded in eager-loading.
func (e SalleEdges) ProfilReservationOrErr() ([]*Profile, error) {
	if e.loadedTypes[0] {
		return e.ProfilReservation, nil
	}
	return nil, &NotLoadedError{edge: "profil_reservation"}
}

// DisponibiliteOrErr returns the Disponibilite value or an error if the edge
// was not loaded in eager-loading.
func (e SalleEdges) DisponibiliteOrErr() ([]*SalleDisponible, error) {
	if e.loadedTypes[1] {
		return e.Disponibilite, nil
	}
	return nil, &NotLoadedError{edge: "disponibilite"}
}

// ReservationsOrErr returns the Reservations value or an error if the edge
// was not loaded in eager-loading.
func (e SalleEdges) ReservationsOrErr() ([]*Reservation, error) {
	if e.loadedTypes[2] {
		return e.Reservations, nil
	}
	return nil, &NotLoadedError{edge: "reservations"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Salle) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case salle.FieldID, salle.FieldCapMax:
			values[i] = new(sql.NullInt64)
		case salle.FieldNom, salle.FieldBatiment, salle.FieldEtage, salle.FieldNumSalle:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Salle", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Salle fields.
func (s *Salle) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case salle.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			s.ID = int(value.Int64)
		case salle.FieldNom:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field nom", values[i])
			} else if value.Valid {
				s.Nom = value.String
			}
		case salle.FieldBatiment:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field batiment", values[i])
			} else if value.Valid {
				s.Batiment = value.String
			}
		case salle.FieldEtage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field etage", values[i])
			} else if value.Valid {
				s.Etage = value.String
			}
		case salle.FieldNumSalle:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field num_salle", values[i])
			} else if value.Valid {
				s.NumSalle = value.String
			}
		case salle.FieldCapMax:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field cap_max", values[i])
			} else if value.Valid {
				s.CapMax = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryProfilReservation queries the "profil_reservation" edge of the Salle entity.
func (s *Salle) QueryProfilReservation() *ProfileQuery {
	return (&SalleClient{config: s.config}).QueryProfilReservation(s)
}

// QueryDisponibilite queries the "disponibilite" edge of the Salle entity.
func (s *Salle) QueryDisponibilite() *SalleDisponibleQuery {
	return (&SalleClient{config: s.config}).QueryDisponibilite(s)
}

// QueryReservations queries the "reservations" edge of the Salle entity.
func (s *Salle) QueryReservations() *ReservationQuery {
	return (&SalleClient{config: s.config}).QueryReservations(s)
}

// Update returns a builder for updating this Salle.
// Note that you need to call Salle.Unwrap() before calling this method if this Salle
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Salle) Update() *SalleUpdateOne {
	return (&SalleClient{config: s.config}).UpdateOne(s)
}

// Unwrap unwraps the Salle entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Salle) Unwrap() *Salle {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Salle is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Salle) String() string {
	var builder strings.Builder
	builder.WriteString("Salle(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("nom=")
	builder.WriteString(s.Nom)
	builder.WriteString(", ")
	builder.WriteString("batiment=")
	builder.WriteString(s.Batiment)
	builder.WriteString(", ")
	builder.WriteString("etage=")
	builder.WriteString(s.Etage)
	builder.WriteString(", ")
	builder.WriteString("num_salle=")
	builder.WriteString(s.NumSalle)
	builder.WriteString(", ")
	builder.WriteString("cap_max=")
	builder.WriteString(fmt.Sprintf("%v", s.CapMax))
	builder.WriteByte(')')
	return builder.String()
}

// Salles is a parsable slice of Salle.
type Salles []*Salle

func (s Salles) config(cfg config) {
	for _i := range s {
		s[_i].config = cfg
	}
}
